## Нефункциональные требования и реализация

### 1. Безопасность

- **Транспорт**: использование HTTPS на уровне балансировщика/Ingress.
- **Защита API**:
  - `helmet` подключён в `api/src/index.ts` для базовых HTTP‑заголовков безопасности.
  - `cors` с настройкой разрешённых доменов через `CORS_ORIGIN`.
- **Аутентификация и авторизация**:
  - JWT‑токены доступа + refresh‑токены (реализация заложена в GraphQL‑схему через `AuthPayload`).
  - Ролевая модель (RBAC) основана на сущностях `User`, `Role`, `UserRole` в PostgreSQL.
- **Хранение файлов**:
  - доступ к 3D‑моделям только через подписанные S3‑URL и проверку прав по заказу.

### 2. Производительность и масштабируемость

- **Кэширование**:
  - Redis для кэша справочников (материалы, категории) и тяжёлых расчётов калькулятора.
- **Масштабирование**:
  - `api` и `web` запускаются как stateless‑сервисы и могут масштабироваться горизонтально (Deployment в Kubernetes).
  - БД и Redis выносятся в управляемые сервисы в прод‑окружении.
- **Фронтенд**:
  - Next.js с code‑splitting и ленивой загрузкой тяжёлых модулей (3D‑просмотрщик).

### 3. Логирование и мониторинг

- **Логи приложений**:
  - HTTP‑запросы логируются через `morgan` в `api/src/index.ts`.
  - В перспективе — отправка логов в централизованное хранилище (ELK/Cloud Logging).
- **Бизнес‑метрики**:
  - агрегации и срезы сохраняются в MongoDB коллекции `analytics_snapshots`.
- **Health‑чеки**:
  - HTTP‑endpoint `/health` и GraphQL‑запрос `health` для проверки доступности сервиса.

Эти механизмы задают базовый уровень нефункциональных требований, который может расширяться по мере роста нагрузки и требований к надёжности.

